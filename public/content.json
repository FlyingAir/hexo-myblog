{"meta":{"title":"ヽ(￣▽￣)ﾉ","subtitle":null,"description":"jonyjay的个人博客！","author":"Jony Jay","url":"http://blog.jonyjay.com"},"pages":[{"title":"","date":"2017-12-21T10:12:01.628Z","updated":"2017-12-21T10:12:01.628Z","comments":true,"path":"baidu_verify_FOVRu3iTRH.html","permalink":"http://blog.jonyjay.com/baidu_verify_FOVRu3iTRH.html","excerpt":"","text":"FOVRu3iTRH"},{"title":"","date":"2017-12-21T10:12:34.077Z","updated":"2017-12-21T10:12:34.077Z","comments":true,"path":"googled4d43399f2f06199.html","permalink":"http://blog.jonyjay.com/googled4d43399f2f06199.html","excerpt":"","text":"google-site-verification: googled4d43399f2f06199.html"},{"title":"about","date":"2017-12-05T05:48:35.000Z","updated":"2017-12-14T02:40:13.111Z","comments":false,"path":"about/index.html","permalink":"http://blog.jonyjay.com/about/index.html","excerpt":"","text":""},{"title":"categories","date":"2017-12-05T05:48:08.000Z","updated":"2017-12-12T03:11:34.553Z","comments":false,"path":"categories/index.html","permalink":"http://blog.jonyjay.com/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2017-12-05T05:47:39.000Z","updated":"2017-12-12T03:11:18.810Z","comments":false,"path":"tags/index.html","permalink":"http://blog.jonyjay.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"JavaScript知识点整理","slug":"javascript知识点整理","date":"2018-04-10T02:11:03.905Z","updated":"2018-04-11T06:51:04.629Z","comments":true,"path":"/posts/16111/","link":"","permalink":"http://blog.jonyjay.com/posts/16111/","excerpt":"看到的、用到的一些js知识点整理","text":"看到的、用到的一些js知识点整理 前言好记性不如烂笔头！更何况没有好记性！ 正文JavaScript 作用域词法作用域 简单地说，词法作用域就是定义在词法阶段的作用域。换句话说，词法作用域是由你在写代码时将变量和块作用域写在哪里来决定的，因此当词法分析器处理代码时会保持作用域不变(大部分情况下是这样的)。 动态作用域 在JS里，动态作用域和this机制息息相关。它的作用域诗是在运行的过程中确定的 区别： 词法作用域是在写代码或者说定义时确定的，而动态作用域是在运行时确定的。 词法作用域关注函数在何处声明，而动态作用域关注函数从何处调用。 函数作用域js中，生成作用域的方式： 函数 with、eval (不建议使用，影响性能) 最小授权原则 最小授权原则是指在软件设计中，应该最小限度地暴露必要内容，而将其他内容都“隐藏”起来，比如某个模块或对象的 API 设计。 上下文执行细节创建阶段 创建变量对象创建变量对象，依次经历了以下几个步骤 建立arguments对象。检测当前上下文参数，建立该对对象下的属性及属性值。（这里提一下，函数的参数是按值传递，我知道你是知道的） 检测关键词function函数声明。检测当前上下文中的函数声明，并挂载到变量对象上，其值是函数对象的引用。 检测var变量声明。检测当前上下文中的var声明，并赋值为undefined;如遇到同名var声明的变量，则会默认覆盖;如遇到同名函数声明，则默认忽略，这也就体现了函数声明的优先级要高于var声明。谁的大哥还是得分清的，哈哈。。。JS内部运行机制编译阶段词法分析（Lexing） 这个过程会将由字符组成的字符串分解成(对编程语言来说)有意义的代码块，这些代 码块被称为词法单元(token)。语法分析（Parsing）这个过程是将词法单元流(数组)转换成一个由元素逐级嵌套所组成的代表了程序语法 结构的树。这个树被称为“抽象语法树”(Abstract Syntax Tree，AST)。生成可执行代码将 AST 转换为可执行代码的过程称被称为代码生成。 执行阶段 this(哪个对象调用函数，函数里面的this指向哪个对象)new()做了什么 创建一个新对象 将构造函数的作用域赋给新对象（因此this就指向了这个新对象） 执行构造函数中的代码（为这个新对象添加属性） 返回新对象 注意点：在构造函数里面返回一个对象，会直接返回这个对象，而不是执行构造函数后创建的对象12345678let TestClass = fucntion()&#123; this.name='JonyJay'; return &#123; username: 'fay' &#125;&#125;let subClass = newTestClass();//&#123;username:'fay'&#125; apply和call调用call 和 apply 的作用，完全一样，唯一的区别就是在参数上面。call 接收的参数不固定，第一个参数是函数体内 this 的指向，第二个参数以下是依次传入的参数。apply接收两个参数，第一个参数也是函数体内 this 的指向。第二个参数是一个集合对象（数组或者类数组）12345678let fn=function(a,b,c)&#123;console.log(a,b,c);&#125;let arr=[1,2,3];fn.call(window,arr)//[1,2,3]fn.apply(window,arr)//1,2,3 12345678910let obj1=&#123; a:222&#125;;let obj2=&#123; a:111, fn:function()&#123; alert(this.a); &#125;&#125;obj2.fn.call(obj1); 此时虽然是 obj2 调用方法，但是使用 了call，动态的把 this 指向到 obj1。相当于这个 obj2.fn 这个执行环境是 obj1 箭头函数调用箭头函数里面，没有 this ，箭头函数里面的 this 是继承外面的环境。1234567let obj=&#123; a:222, fn:function()&#123; setTimeout(function()&#123;console.log(this.a)&#125;) &#125;&#125;;obj.fn();//undefined 虽然 fn()里面的 this是指向 obj，但是，传给 setTimeout的是普通函数， this指向是 window， window下面没有 a，所以这里输出 undefined。1234567let obj=&#123; a:222, fn:function()&#123; setTimeout(()=&gt;&#123;console.log(this.a)&#125;); &#125;&#125;;obj.fn();//222 这次输出 222 是因为，传给 setTimeout的是箭头函数，然后箭头函数里面没有 this，所以要向上层作用域查找，在这个例子上， setTimeout的上层作用域是 fn。而 fn 里面的 this指向 obj ，所以 setTimeout里面的箭头函数的 this，指向 obj。所以输出 222 闭包当一个函数能够记住并访问到其所在的词法作用域及作用域链，特别强调是在其定义的作用域外进行的访问，此时该函数和其上层执行上下文共同构成闭包。 闭包一定是函数对象 闭包和词法作用域，作用域链，垃圾回收机制息息相关 当函数一定是在其定义的作用域外进行的访问时，才产生闭包 闭包是由该函数和其上层执行上下文共同构成123456789let add=(function()&#123; let now=0; return &#123; doAdd:function()&#123; now++; console.log(now); &#125; &#125;&#125;)() 闭包的应用的注意事项内存泄漏（Memory Leak)使用完毕置 null 清空 闭包的应用 模块一个模块应该具有私有属性、私有方法和公有属性、公有方法。而闭包能很好的将模块的公有属性、方法暴露出来。123456789101112131415var myModule = (function (window, undefined) &#123; let name = \"echo\"; function getName() &#123; return name; &#125; return &#123; name, getName &#125;&#125;)(window);console.log( myModule.name ); // echoconsole.log( myModule.getName() ); // echo “return”关键字将对象引用导出赋值给myModule，从而应用到闭包。 延时器(setTimeout)、计数器(setInterval)12345678910111213for( var i = 0; i &lt; 5; i++ ) &#123; setTimeout(() =&gt; &#123; console.log( i ); &#125;, 1000 * i)&#125;=&gt;for( var i = 0; i &lt; 5; i++ ) &#123; (j)=&gt;&#123; setTimeout(() =&gt; &#123; console.log( j ); &#125;, 1000 * j) &#125;(i)&#125;","categories":[{"name":"前端","slug":"前端","permalink":"http://blog.jonyjay.com/categories/前端/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://blog.jonyjay.com/tags/JavaScript/"}]},{"title":"前端开发工作中遇到的问题整理","slug":"前端开发工作中遇到的冷门问题整理","date":"2018-04-09T06:20:56.637Z","updated":"2018-04-13T05:24:21.736Z","comments":true,"path":"/posts/16110/","link":"","permalink":"http://blog.jonyjay.com/posts/16110/","excerpt":"整理一些前端开发工作中遇到的冷门问题。","text":"整理一些前端开发工作中遇到的冷门问题。 前言工作中遇到的一些问题 正文transform：translate(50%,50%)的坑 最近在项目提交后测试部门反馈这样的问题，在模态框打开后其中的文字和边框都出现了模糊的现象。经查看发现问题原因：由于图层渲染的时候也处理了周围的文字，如果高度为奇数的文字可能会存在半个像素的计算量，浏览器对这半个像素会进行优化渲染，所以边缘会出现模糊的情况。 优化方法： 将元素的高度、宽度设置为偶数可解决； vue.js 数据渲染成功仍报错的问题场景：dom中数据分两个接口同步获取，第一个接口获取完数据，dom直接加载，第二个接口数据未获取报错undefined，但是数据展示正常，因为第二个接口获取数据后再次渲染更新。 123456789axios.post().then(res)=&gt;&#123; VM.links = res.data; VM.getData(); &#125; getData()&#123; axios.post().then(res)=&gt;&#123; VM.showData = res.data &#125; &#125; 123&lt;div v-for=\"(item,index) in links\"&gt; &lt;span v-if=\"links[index]['isTrue']\"&gt; item.show&lt;span&gt; &lt;/div&gt; 这里会报错 isTrue undefined；解决方案 : 将代码都放在中12345&lt;template&gt; &lt;div v-if=\"!loading\"&gt; &lt;!----你的html代码------&gt; &lt;/div&gt;&lt;/template&gt; 123456getData()&#123; axios.post().then(res)=&gt;&#123; VM.showData = res.data VM.loading =false //等两个接口都请求结束再渲染dom即可 &#125;&#125; 结束语over ! over !","categories":[{"name":"前端","slug":"前端","permalink":"http://blog.jonyjay.com/categories/前端/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://blog.jonyjay.com/tags/JavaScript/"},{"name":"Css","slug":"Css","permalink":"http://blog.jonyjay.com/tags/Css/"},{"name":"Html","slug":"Html","permalink":"http://blog.jonyjay.com/tags/Html/"}]},{"title":"各种酷炫的Github头像、图片","slug":"各种酷炫github头像","date":"2017-12-14T11:00:13.607Z","updated":"2018-04-13T05:25:34.466Z","comments":true,"path":"/posts/16109/","link":"","permalink":"http://blog.jonyjay.com/posts/16109/","excerpt":"各种酷炫github头像！总有一款你喜欢的。","text":"各种酷炫github头像！总有一款你喜欢的。 随意下载。高能多图预警！","categories":[{"name":"杂","slug":"杂","permalink":"http://blog.jonyjay.com/categories/杂/"}],"tags":[{"name":"娱乐","slug":"娱乐","permalink":"http://blog.jonyjay.com/tags/娱乐/"},{"name":"github","slug":"github","permalink":"http://blog.jonyjay.com/tags/github/"}]},{"title":"基于DaoCloud的持续化环境配置","slug":"基于DaoCloud、nginx反向代理的单服务器多项目配置","date":"2017-12-14T05:06:07.212Z","updated":"2018-04-09T06:22:26.110Z","comments":true,"path":"/posts/16108/","link":"","permalink":"http://blog.jonyjay.com/posts/16108/","excerpt":"基于DaoCloud、nginx反向代理的单服务器多项目配置。","text":"基于DaoCloud、nginx反向代理的单服务器多项目配置。本文基于 https://juejin.im/post/5a142d7b6fb9a0451170c2c7 《 基于 Docker 打造前端持续集成开发环境》 ，小白研究了偷懒的方法。如有大神有更好的办法，请赐教。 基于DaoCloud、nginx反向代理的单服务器多项目配置目标： 代码无需在本地构建 只需将代码推上 Github ，自动部署 版本易管理，可轻松回退版本 配置多个docker容器指向 服务器不同端口，通过nginx反向代理 用简单的vue-cli项目举例第一步： 初始化 Vue 项目（使用vue官方脚手架 vue-cli） 初始化 vue 项目：vue init webpack jay-www 在项目根目录下编 Dockerfile 这里的DockerFIle配置没有仔细看 - - 只求偷懒。 技术有限，写的也都是些杂七杂八的就不做.gitignore /dist了,项目中直接构建好了提交。有各种优化Docker 容器运行速度的方法请google/baidu 初始化 git， 连接并将代码推送到 Github 仓库， 第二步：使用 DaoCloud 搭建 开发流程 注册一个 DaoCloud 账号 用户中心 -&gt; 代码托管，授权可访问你的 Github 仓库 在 Devops 项目中新建一个项目，并选择 Github 中对应刚才新创建的项目 先手动构建一个镜像版本，便于下面用这个镜像版本创建一个应用 连接自有主机 太酷了，我们已经将我们的主机接入了 DaoCloud，接下来就来完成最有意思的一步。 创建一个应用 进入【镜像仓库】选择刚才手动构建出来的镜像，并部署最新版本到自由主机或者云端测试环境 稍等片刻，便可以点击“立即部署” 这边需要注意 : 主机端口 将会与主机中nginx反向代理配置有关系 7.定义自动构建，自动发布任务 至此，我们已经完成了，所有流程控制工作，去测试一下整个流程是否能走通？ 第三步： 测试整个流程回到我们本地，修改一下文本内容，提交，并推送到远端， 至此，我们在只编写了一个 Dockerfile 配置文件，没有编写脚本的情况下，成功地搭建了一套前端的持续集成开发环境。 配置单主机不同域名 对应不同项目通过重复上面的操作，docker容器指向不同的主机端口。只要在主机nginx配置不同反向代理即可。研究了两天发现这个是最快捷的。最偷懒的 - - 虽然有很多弊端。。。仅供参考娱乐 ，不适合正规开发 。 作者：三环没有少 链接：https://juejin.im/post/5a142d7b6fb9a0451170c2c7 来源：掘金 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。","categories":[{"name":"效率工具","slug":"效率工具","permalink":"http://blog.jonyjay.com/categories/效率工具/"}],"tags":[{"name":"docker","slug":"docker","permalink":"http://blog.jonyjay.com/tags/docker/"},{"name":"nginx","slug":"nginx","permalink":"http://blog.jonyjay.com/tags/nginx/"}]},{"title":"Hello World","slug":"hello-world","date":"2017-12-05T05:36:16.880Z","updated":"2018-04-09T06:22:39.480Z","comments":true,"path":"/posts/16107/","link":"","permalink":"http://blog.jonyjay.com/posts/16107/","excerpt":"这是一篇用来测试的文章。","text":"这是一篇用来测试的文章。 Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[{"name":"杂","slug":"杂","permalink":"http://blog.jonyjay.com/categories/杂/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://blog.jonyjay.com/tags/Hexo/"}]}]}