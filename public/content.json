{"meta":{"title":"ヽ(￣▽￣)ﾉ","subtitle":null,"description":"jonyjay的个人博客！","author":"Jony Jay","url":"http://blog.jonyjay.com"},"pages":[{"title":"","date":"2019-04-08T09:02:33.072Z","updated":"2019-04-08T09:02:33.072Z","comments":true,"path":"baidu_verify_FOVRu3iTRH.html","permalink":"http://blog.jonyjay.com/baidu_verify_FOVRu3iTRH.html","excerpt":"","text":"FOVRu3iTRH"},{"title":"","date":"2019-04-08T09:02:33.074Z","updated":"2019-04-08T09:02:33.074Z","comments":true,"path":"googled4d43399f2f06199.html","permalink":"http://blog.jonyjay.com/googled4d43399f2f06199.html","excerpt":"","text":"google-site-verification: googled4d43399f2f06199.html"},{"title":"about","date":"2017-12-05T05:48:35.000Z","updated":"2019-04-08T09:02:33.072Z","comments":false,"path":"about/index.html","permalink":"http://blog.jonyjay.com/about/index.html","excerpt":"","text":""},{"title":"categories","date":"2017-12-05T05:48:08.000Z","updated":"2019-04-08T09:02:33.073Z","comments":false,"path":"categories/index.html","permalink":"http://blog.jonyjay.com/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2017-12-05T05:47:39.000Z","updated":"2019-04-08T09:02:33.075Z","comments":false,"path":"tags/index.html","permalink":"http://blog.jonyjay.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"","slug":"前端安全","date":"2019-04-09T02:10:44.555Z","updated":"2019-04-09T02:11:17.356Z","comments":true,"path":"/posts/0/","link":"","permalink":"http://blog.jonyjay.com/posts/0/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"常见面试题 - JS","slug":"常见面试题 - JS","date":"2019-04-08T09:02:33.071Z","updated":"2019-04-08T09:02:33.071Z","comments":true,"path":"/posts/16112/","link":"","permalink":"http://blog.jonyjay.com/posts/16112/","excerpt":"一些常见面试题的整理","text":"一些常见面试题的整理 数组去除ES6的set()123var arr =[1,2,3,4,3,2,1];var arrSet =new Set(arr);var newArr = [...arrSet]; //[1,2,3,4] 使用push12345678var arr = [1,2,3,4,3,2,1];var newArr =[];for (var index = 0; index &lt; arr.length; index++) &#123; if(newArr.indexOf(arr[index])== -1)&#123; newArr.push(arr[index]); &#125;&#125;console.log(newArr)//[1,2,3,4] 排序去除相邻重复元素12345678var arr = [1, 2, 3, 4, 3, 2, 1];var arr = arr.sort();for (var i = 0; i &lt; arr.length-1; i++) &#123; if(arr[i] == arr[i+1])&#123; arr.splice(i,1) &#125;&#125;console.log(arr)//[1,2,3,4]","categories":[{"name":"前端","slug":"前端","permalink":"http://blog.jonyjay.com/categories/前端/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://blog.jonyjay.com/tags/JavaScript/"}]},{"title":"各种酷炫的Github头像、图片","slug":"各种酷炫github头像","date":"2019-04-08T09:02:33.070Z","updated":"2019-04-08T09:02:33.070Z","comments":true,"path":"/posts/16109/","link":"","permalink":"http://blog.jonyjay.com/posts/16109/","excerpt":"各种酷炫github头像！总有一款你喜欢的。","text":"各种酷炫github头像！总有一款你喜欢的。 随意下载。高能多图预警！","categories":[{"name":"杂","slug":"杂","permalink":"http://blog.jonyjay.com/categories/杂/"}],"tags":[{"name":"娱乐","slug":"娱乐","permalink":"http://blog.jonyjay.com/tags/娱乐/"},{"name":"github","slug":"github","permalink":"http://blog.jonyjay.com/tags/github/"}]},{"title":"基于DaoCloud的持续化环境配置","slug":"基于DaoCloud、nginx反向代理的单服务器多项目配置","date":"2019-04-08T09:02:33.070Z","updated":"2019-04-08T09:02:33.070Z","comments":true,"path":"/posts/16108/","link":"","permalink":"http://blog.jonyjay.com/posts/16108/","excerpt":"基于DaoCloud、nginx反向代理的单服务器多项目配置。","text":"基于DaoCloud、nginx反向代理的单服务器多项目配置。本文基于 https://juejin.im/post/5a142d7b6fb9a0451170c2c7 《 基于 Docker 打造前端持续集成开发环境》 ，小白研究了偷懒的方法。如有大神有更好的办法，请赐教。 基于DaoCloud、nginx反向代理的单服务器多项目配置目标： 代码无需在本地构建 只需将代码推上 Github ，自动部署 版本易管理，可轻松回退版本 配置多个docker容器指向 服务器不同端口，通过nginx反向代理 用简单的vue-cli项目举例第一步： 初始化 Vue 项目（使用vue官方脚手架 vue-cli） 初始化 vue 项目：vue init webpack jay-www 在项目根目录下编 Dockerfile 这里的DockerFIle配置没有仔细看 - - 只求偷懒。 技术有限，写的也都是些杂七杂八的就不做.gitignore /dist了,项目中直接构建好了提交。有各种优化Docker 容器运行速度的方法请google/baidu 初始化 git， 连接并将代码推送到 Github 仓库， 第二步：使用 DaoCloud 搭建 开发流程 注册一个 DaoCloud 账号 用户中心 -&gt; 代码托管，授权可访问你的 Github 仓库 在 Devops 项目中新建一个项目，并选择 Github 中对应刚才新创建的项目 先手动构建一个镜像版本，便于下面用这个镜像版本创建一个应用 连接自有主机 太酷了，我们已经将我们的主机接入了 DaoCloud，接下来就来完成最有意思的一步。 创建一个应用 进入【镜像仓库】选择刚才手动构建出来的镜像，并部署最新版本到自由主机或者云端测试环境 稍等片刻，便可以点击“立即部署” 这边需要注意 : 主机端口 将会与主机中nginx反向代理配置有关系 7.定义自动构建，自动发布任务 至此，我们已经完成了，所有流程控制工作，去测试一下整个流程是否能走通？ 第三步： 测试整个流程回到我们本地，修改一下文本内容，提交，并推送到远端， 至此，我们在只编写了一个 Dockerfile 配置文件，没有编写脚本的情况下，成功地搭建了一套前端的持续集成开发环境。 配置单主机不同域名 对应不同项目通过重复上面的操作，docker容器指向不同的主机端口。只要在主机nginx配置不同反向代理即可。研究了两天发现这个是最快捷的。最偷懒的 - - 虽然有很多弊端。。。仅供参考娱乐 ，不适合正规开发 。 作者：三环没有少 链接：https://juejin.im/post/5a142d7b6fb9a0451170c2c7 来源：掘金 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。","categories":[{"name":"效率工具","slug":"效率工具","permalink":"http://blog.jonyjay.com/categories/效率工具/"}],"tags":[{"name":"docker","slug":"docker","permalink":"http://blog.jonyjay.com/tags/docker/"},{"name":"nginx","slug":"nginx","permalink":"http://blog.jonyjay.com/tags/nginx/"}]},{"title":"JavaScript知识点整理","slug":"javascript知识点整理","date":"2019-04-08T09:02:33.069Z","updated":"2019-04-08T09:02:33.069Z","comments":true,"path":"/posts/16111/","link":"","permalink":"http://blog.jonyjay.com/posts/16111/","excerpt":"看到的、用到的一些js知识点整理","text":"看到的、用到的一些js知识点整理 前言好记性不如烂笔头！更何况没有好记性！ 正文JavaScript 作用域词法作用域 简单地说，词法作用域就是定义在词法阶段的作用域。换句话说，词法作用域是由你在写代码时将变量和块作用域写在哪里来决定的，因此当词法分析器处理代码时会保持作用域不变(大部分情况下是这样的)。 动态作用域 在JS里，动态作用域和this机制息息相关。它的作用域诗是在运行的过程中确定的 区别： 词法作用域是在写代码或者说定义时确定的，而动态作用域是在运行时确定的。 词法作用域关注函数在何处声明，而动态作用域关注函数从何处调用。 函数作用域js中，生成作用域的方式： 函数 with、eval (不建议使用，影响性能) 最小授权原则 最小授权原则是指在软件设计中，应该最小限度地暴露必要内容，而将其他内容都“隐藏”起来，比如某个模块或对象的 API 设计。 上下文执行细节创建阶段 创建变量对象创建变量对象，依次经历了以下几个步骤 建立arguments对象。检测当前上下文参数，建立该对对象下的属性及属性值。（这里提一下，函数的参数是按值传递，我知道你是知道的） 检测关键词function函数声明。检测当前上下文中的函数声明，并挂载到变量对象上，其值是函数对象的引用。 检测var变量声明。检测当前上下文中的var声明，并赋值为undefined;如遇到同名var声明的变量，则会默认覆盖;如遇到同名函数声明，则默认忽略，这也就体现了函数声明的优先级要高于var声明。谁的大哥还是得分清的，哈哈。。。JS内部运行机制编译阶段词法分析（Lexing） 这个过程会将由字符组成的字符串分解成(对编程语言来说)有意义的代码块，这些代 码块被称为词法单元(token)。语法分析（Parsing）这个过程是将词法单元流(数组)转换成一个由元素逐级嵌套所组成的代表了程序语法 结构的树。这个树被称为“抽象语法树”(Abstract Syntax Tree，AST)。生成可执行代码将 AST 转换为可执行代码的过程称被称为代码生成。 执行阶段 this(哪个对象调用函数，函数里面的this指向哪个对象)new()做了什么 创建一个新对象 将构造函数的作用域赋给新对象（因此this就指向了这个新对象） 执行构造函数中的代码（为这个新对象添加属性） 返回新对象 注意点：在构造函数里面返回一个对象，会直接返回这个对象，而不是执行构造函数后创建的对象12345678let TestClass = fucntion()&#123; this.name='JonyJay'; return &#123; username: 'fay' &#125;&#125;let subClass = newTestClass();//&#123;username:'fay'&#125; apply和call调用call 和 apply 的作用，完全一样，唯一的区别就是在参数上面。call 接收的参数不固定，第一个参数是函数体内 this 的指向，第二个参数以下是依次传入的参数。apply接收两个参数，第一个参数也是函数体内 this 的指向。第二个参数是一个集合对象（数组或者类数组）12345678let fn=function(a,b,c)&#123;console.log(a,b,c);&#125;let arr=[1,2,3];fn.call(window,arr)//[1,2,3]fn.apply(window,arr)//1,2,3 12345678910let obj1=&#123; a:222&#125;;let obj2=&#123; a:111, fn:function()&#123; alert(this.a); &#125;&#125;obj2.fn.call(obj1); 此时虽然是 obj2 调用方法，但是使用 了call，动态的把 this 指向到 obj1。相当于这个 obj2.fn 这个执行环境是 obj1 箭头函数调用箭头函数里面，没有 this ，箭头函数里面的 this 是继承外面的环境。1234567let obj=&#123; a:222, fn:function()&#123; setTimeout(function()&#123;console.log(this.a)&#125;) &#125;&#125;;obj.fn();//undefined 虽然 fn()里面的 this是指向 obj，但是，传给 setTimeout的是普通函数， this指向是 window， window下面没有 a，所以这里输出 undefined。1234567let obj=&#123; a:222, fn:function()&#123; setTimeout(()=&gt;&#123;console.log(this.a)&#125;); &#125;&#125;;obj.fn();//222 这次输出 222 是因为，传给 setTimeout的是箭头函数，然后箭头函数里面没有 this，所以要向上层作用域查找，在这个例子上， setTimeout的上层作用域是 fn。而 fn 里面的 this指向 obj ，所以 setTimeout里面的箭头函数的 this，指向 obj。所以输出 222 闭包当一个函数能够记住并访问到其所在的词法作用域及作用域链，特别强调是在其定义的作用域外进行的访问，此时该函数和其上层执行上下文共同构成闭包。 闭包一定是函数对象 闭包和词法作用域，作用域链，垃圾回收机制息息相关 当函数一定是在其定义的作用域外进行的访问时，才产生闭包 闭包是由该函数和其上层执行上下文共同构成123456789let add=(function()&#123; let now=0; return &#123; doAdd:function()&#123; now++; console.log(now); &#125; &#125;&#125;)() 闭包的应用的注意事项内存泄漏（Memory Leak)使用完毕置 null 清空 闭包的应用 模块一个模块应该具有私有属性、私有方法和公有属性、公有方法。而闭包能很好的将模块的公有属性、方法暴露出来。123456789101112131415var myModule = (function (window, undefined) &#123; let name = \"echo\"; function getName() &#123; return name; &#125; return &#123; name, getName &#125;&#125;)(window);console.log( myModule.name ); // echoconsole.log( myModule.getName() ); // echo “return”关键字将对象引用导出赋值给myModule，从而应用到闭包。 延时器(setTimeout)、计数器(setInterval)12345678910111213for( var i = 0; i &lt; 5; i++ ) &#123; setTimeout(() =&gt; &#123; console.log( i ); &#125;, 1000 * i)&#125;=&gt;for( var i = 0; i &lt; 5; i++ ) &#123; (j)=&gt;&#123; setTimeout(() =&gt; &#123; console.log( j ); &#125;, 1000 * j) &#125;(i)&#125;","categories":[{"name":"前端","slug":"前端","permalink":"http://blog.jonyjay.com/categories/前端/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://blog.jonyjay.com/tags/JavaScript/"}]},{"title":"前端开发工作中遇到的问题整理","slug":"前端开发工作中遇到的问题整理","date":"2019-04-08T09:02:33.069Z","updated":"2019-04-08T09:02:33.069Z","comments":true,"path":"/posts/16110/","link":"","permalink":"http://blog.jonyjay.com/posts/16110/","excerpt":"整理一些前端开发工作中遇到的问题。","text":"整理一些前端开发工作中遇到的问题。 前言工作中遇到的一些问题 正文transform：translate(50%,50%)的坑 最近在项目提交后测试部门反馈这样的问题，在模态框打开后其中的文字和边框都出现了模糊的现象。经查看发现问题原因：由于图层渲染的时候也处理了周围的文字，如果高度为奇数的文字可能会存在半个像素的计算量，浏览器对这半个像素会进行优化渲染，所以边缘会出现模糊的情况。 优化方法： 将元素的高度、宽度设置为偶数可解决； vue.js 数据渲染成功仍报错的问题场景：dom中数据分两个接口同步获取，第一个接口获取完数据，dom直接加载，第二个接口数据未获取报错undefined，但是数据展示正常，因为第二个接口获取数据后再次渲染更新。 123456789axios.post().then(res)=&gt;&#123; VM.links = res.data; VM.getData(); &#125; getData()&#123; axios.post().then(res)=&gt;&#123; VM.showData = res.data &#125; &#125; 123&lt;div v-for=\"(item,index) in links\"&gt; &lt;span v-if=\"links[index]['isTrue']\"&gt; item.show&lt;span&gt; &lt;/div&gt; 这里会报错 isTrue undefined；解决方案 : 将代码都放在中12345&lt;template&gt; &lt;div v-if=\"!loading\"&gt; &lt;!----你的html代码------&gt; &lt;/div&gt;&lt;/template&gt; 123456getData()&#123; axios.post().then(res)=&gt;&#123; VM.showData = res.data VM.loading =false //等两个接口都请求结束再渲染dom即可 &#125;&#125; vue.js 深层数据报错undefined12345 &lt;template scope=\"scope\"&gt; &lt;div v-if=\"isFinished01 &amp;&amp; isFinished02\"&gt; &lt;div&gt;&#123;&#123;(systemDock[scope.row.systemDocking]).cdVal&#125;&#125;&lt;/div&gt; &lt;/div&gt;&lt;/template&gt; 在这里 systemDocking和systemDock 是两个接口返回的数据，isFinished01、isFinished02分别是两个接口返回成功是否的状态，但是一直会报错cdValundefined. 解决方案：12345 &lt;template scope=\"scope\"&gt; &lt;div v-if=\"isFinished01 &amp;&amp; isFinished02\"&gt; &lt;div v-if=\"systemDock[scope.row.systemDocking]\"&gt;&#123;&#123;(systemDock[scope.row.systemDocking]).cdVal&#125;&#125;&lt;/div&gt; &lt;/div&gt;&lt;/template&gt; 等获取到systemDock[scope.row.systemDocking]这个对象之后再进行渲染 ### 结束语over ! over !","categories":[{"name":"前端","slug":"前端","permalink":"http://blog.jonyjay.com/categories/前端/"}],"tags":[{"name":"Html","slug":"Html","permalink":"http://blog.jonyjay.com/tags/Html/"},{"name":"Css","slug":"Css","permalink":"http://blog.jonyjay.com/tags/Css/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://blog.jonyjay.com/tags/JavaScript/"}]},{"title":"Hello World","slug":"hello-world","date":"2019-04-08T09:02:33.068Z","updated":"2019-04-08T09:02:33.068Z","comments":true,"path":"/posts/16107/","link":"","permalink":"http://blog.jonyjay.com/posts/16107/","excerpt":"这是一篇用来测试的文章。","text":"这是一篇用来测试的文章。 Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[{"name":"杂","slug":"杂","permalink":"http://blog.jonyjay.com/categories/杂/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://blog.jonyjay.com/tags/Hexo/"}]},{"title":"H5开发实战总结","slug":"H5开发实战总结","date":"2019-04-08T09:02:33.067Z","updated":"2019-04-08T09:02:33.068Z","comments":true,"path":"/posts/16555/","link":"","permalink":"http://blog.jonyjay.com/posts/16555/","excerpt":"H5开发实战小册总结","text":"H5开发实战小册总结 前言一边看小册一边学习记录 正文基本页面开发步骤1 - 设计稿审查 了解设计稿的开发友好性哪些地方的设计对开发不友好？是否存在展示缺陷？是否开发成本高或者根本无法实现？ 了解设计稿的排版布局及内容构成 跨页面可复用组件(Header、Footer) 当前页面可复用组件(重复部分) ####步骤2 - 编写页面骨骼框架 盒模型content-box（标准盒模型）: 一个块的总宽度= width + padding(左右) + border(左右) IE 浏览器下（怪异盒模型）： 一个块的总宽度= width + margin(左右)（即width已经包含了padding和border值） border-box （怪异盒模型）: 不管 margin + border + padding + content-width 大于还是小于元素宽度 width，盒子的 总宽度始终固定为 width。 布局 普通文档流布局 默认的布局方式，由块级元素（display: block）和行内元素（display: inline）等组成，元素之间按照从左到右，从上到下的顺序排列。 浮动布局 相对于普通文档流布局，浮动布局会脱离普通文档流，分为左右浮动，一般会在普通文档流布局的上面进行界面的布局，如果想避免浮动布局遮盖普通布局的情况，可以考虑使用清除浮动。 添加空div标签 clear:both 父级标签overflow:hidden 父级标签定义伪类after1234567.clearfix:before, .clearfix:after &#123; content:\"\"; display:table; &#125; .clearfix:after&#123; clear:both; overflow:hidden; &#125; .clearfix&#123; zoom:1; &#125; 绝对布局元素使用 position: absolute 属性进行绝对布局，使用绝对布局的元素会脱离文档流，其定位是参考祖先元素中 position 为非 static 值的第一个元素。 弹性布局也称 Flex 布局，是一个完整的模块，而不是一个单一属性，其中有的属性是设置在父元素上，有些则是设置在子元素上。如果我们说传统的布局是建立在块级元素和行内元素的文本流上，那么 Flex 布局就是建立在 flex-flow 的轴方向上的。 网格布局是用于制定行与列的二维 CSS 布局方法，可以将页面分割成数个主要的区域，或者用来定义组件内部元素间的大小、位置和图层之间的关系。语义化h5 语义化标签 步骤3 - 编写页面内容、润色BEM 命名规范BEM 是一种基于组件的命名方法，它的基本思想是将用户界面划分成独立的模块，即使是复杂的用户界面，也能让开发过程变得简单、快速。并且可以在一定程度上提高代码的可复用性，而不用纯粹的复制粘贴。 Block - 模块，名字的单词之间用 `-` 符号连接 Element - 元素，模块中的子元素，用 `__` 符号连接 Modifier - 修饰符，表示父元素或子元素的其他形态，用 `--` 符号连接 步骤4 - 兼容性测试 页面在各个浏览器中，以及不同分辨率下是否能正常显示（HTML / CSS 兼容性） 网页的功能是否能在各个浏览器中正常使用（JavaScript 兼容性）如果遇到兼容性问题，可以按如下步骤处理： 确认触发的场景：什么浏览器，什么版本，什么情况下触发的问题，做到稳定复现。 找出问题原因：是什么问题导致的，具体表现如何？ 确定解决办法：参考现成的解决方案，如哪些属性不能使用以及相应的 Hack 处理 收集兼容性处理方法，积累成文档 响应式页面开发 利用一套代码实现页面的布局和排版以适配不同分辨率的设备。 步骤1 - 添加 viewport meta 标签1&lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1\"&gt; 步骤2 - 使用 Media Queries1234567参数名称 | 参数描述min-width | 当视窗宽度大于或等于指定值时，@media 规则下的样式将被应用max-width | 当视窗宽度小于或等于指定值时，@media 规则下的样式将被应用min-height | 当视窗高度大于或等于指定值时，@media 规则下的样式将被应用max-height | 当视窗高度小于或等于指定值时，@media 规则下的样式将被应用orientation=portrait | 当视窗高度大于或等于宽度时，@media 规则下的样式将被应用orientation=landscape | 当视窗宽度大于高度时，@media 规则下的样式将被应用 2 种用法方法 1，使用 link 标签，根据指定特性引入特定的外部样式文件1&lt;link rel=\"stylesheet\" media=\"(max-width: 640px)\" href=\"max-640px.css\"&gt; 方法 2，直接在 style 标签或 样式文件内使用 @media 规则123@media (max-width: 640px) &#123; /*当视窗宽度小于或等于 640px 时，这里的样式将生效*/&#125; 样式断点123456断点名称 | 断点描述mobile | 移动设备断点，视窗宽度 ≤ 768 pxtablet | 平板电脑设备断点，视窗宽度 ≥ 769 pxdesktop | 桌面电脑断点，视窗宽度 ≥ 1024 pxwidescreen | 宽屏电脑断点，视窗宽度 ≥ 1216 pxfullhd | 高清宽屏电脑断点，视窗宽度 ≥ 1408 px 使用 Viewport 单位及 remMedia Queries 只解决了「为不同特性的浏览器视窗使用不同的样式代码」的问题，而 Viewport 单位及 rem 的应用，则是为了解决第二个问题：让页面元素的尺寸能够依据浏览器视窗尺寸变化而平滑变化。 方法 1 - 仅使用 vw 作为 CSS 长度单位 利用 Sass 函数将设计稿元素尺寸的像素单位转换为 vw 单位 // iPhone 6尺寸作为设计稿基准 $vw_base: 375; @function vw($px) { @return ($px / $vm_base) * 100vw; } 无论是文本字号大小还是布局高宽、间距、留白等都使用 vw 作为 CSS 单位 1 物理像素线（也就是普通屏幕下 1px ，高清屏幕下 0.5px 的情况）采用 transform 属性 scale 实现 12345678910111213141516171819.mod_grid &#123; position: relative; &amp;::after &#123; // 实现1物理像素的下边框线 content: &apos;&apos;; position: absolute; z-index: 1; pointer-events: none; background-color: #ddd; height: 1px; left: 0; right: 0; top: 0; @media only screen and (-webkit-min-device-pixel-ratio: 2) &#123; -webkit-transform: scaleY(0.5); -webkit-transform-origin: 50% 0%; &#125; &#125;&#125; 对于需要保持高宽比的图，应改用 padding-top 实现 1234567891011121314.mod_banner &#123; position: relative; // 使用padding-top 实现宽高比为 100:750 的图片区域 padding-top: percentage(100/750); height: 0; overflow: hidden; img &#123; width: 100%; height: auto; position: absolute; left: 0; top: 0; &#125;&#125; 方法 2 - vw 搭配 rem，寻找最优解 给根元素的字体大小设置随着视窗变化而变化的 vw 单位，这样就可以实现动态改变其大小 其他元素的文本字号大小、布局宽高、间距、留白都是用rem单位 限制根元素字体大小的最大最小值，配合 body 加上最大宽度和最小宽度，实现布局宽度的最大最小限制 12345678910111213141516171819202122// rem 单位换算：定为 75px 只是方便运算，750px-75px、640-64px、1080px-108px，如此类推$vw_fontsize: 75; // iPhone 6尺寸的根元素大小基准值@function rem($px) &#123; @return ($px / $vw_fontsize ) * 1rem;&#125;// 根元素大小使用 vw 单位$vw_design: 750;html &#123; font-size: ($vw_fontsize / ($vw_design / 2)) * 100vw; // 同时，通过Media Queries 限制根元素最大最小值 @media screen and (max-width: 320px) &#123; font-size: 64px; &#125; @media screen and (min-width: 540px) &#123; font-size: 108px; &#125;&#125;// body 也增加最大最小宽度限制，避免默认100%宽度的 block 元素跟随 body 而过大过小body &#123; max-width: 540px; min-width: 320px;&#125; 动态效果开发CSS3 Transition结束语未完待续 …","categories":[{"name":"前端","slug":"前端","permalink":"http://blog.jonyjay.com/categories/前端/"}],"tags":[{"name":"Html","slug":"Html","permalink":"http://blog.jonyjay.com/tags/Html/"},{"name":"Css","slug":"Css","permalink":"http://blog.jonyjay.com/tags/Css/"}]}]}